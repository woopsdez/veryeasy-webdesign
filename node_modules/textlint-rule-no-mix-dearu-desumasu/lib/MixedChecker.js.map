{"version":3,"sources":["../src/MixedChecker.js"],"names":["MixedChecker","context","options","dearuCount","desumasuCount","dearuHitList","desumasuHitList","_queue","Promise","resolve","node","text","then","analyzeOptions","ignoreConjunction","isStrict","retDearu","results","filter","retDesumasu","length","push","matches","ignoreManger","isOver","RuleError","report","overType","getOverType","overHitList","forEach","lastHitNode","hitIndex","range","token","index","isIgnoredIndex","ruleError","outputMessage","preferDearu","preferDesumasu","value"],"mappings":"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","file":"MixedChecker.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport {analyze, isDearu, isDesumasu} from \"analyze-desumasu-dearu\";\nexport default class MixedChecker {\n    /**\n     * @param context\n     * @param {{preferDearu:boolean, preferDesumasu: boolean}} options\n     */\n    constructor(context, options) {\n        this.context = context;\n        /**\n         * 明示的な優先するタイプの指定\n         * @type {{preferDearu: boolean, preferDesumasu: boolean, isStrict: boolean}}\n         */\n        this.options = options;\n        this.dearuCount = 0;\n        this.desumasuCount = 0;\n        this.dearuHitList = [];\n        this.desumasuHitList = [];\n        this._queue = Promise.resolve();\n    }\n\n    check(node, text) {\n        this._queue = this._queue.then(() => {\n            const analyzeOptions = {\n                ignoreConjunction: !this.options.isStrict\n            };\n            return analyze(text, analyzeOptions).then(results => {\n                const retDearu = results.filter(isDearu);\n                const retDesumasu = results.filter(isDesumasu);\n                const dearuCount = this.dearuCount + retDearu.length;\n                const desumasuCount = this.desumasuCount + retDesumasu.length;\n                if (this.dearuCount !== dearuCount) {\n                    this.dearuCount = dearuCount;\n                    this.dearuHitList.push({\n                        node,\n                        matches: retDearu\n                    });\n                }\n                if (this.desumasuCount !== desumasuCount) {\n                    this.desumasuCount = desumasuCount;\n                    this.desumasuHitList.push({\n                        node,\n                        matches: retDesumasu\n                    });\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {IgnoreManger}ignoreManger\n     * @returns {Promise.<TResult>}\n     */\n    checkout(ignoreManger) {\n        return this._queue.then(() => {\n            if (!this.isOver()) {\n                return;\n            }\n            const RuleError = this.context.RuleError;\n            const report = this.context.report;\n            const overType = this.getOverType();\n            const overHitList = this.overHitList(overType);\n            // List\n            overHitList.forEach(({\n                node,\n                matches\n            }) => {\n                // Node\n                const lastHitNode = node;\n                // Tokens\n                matches.forEach(token => {\n                    const hitIndex = node.range[0] + token.index;\n                    if (ignoreManger.isIgnoredIndex(hitIndex)) {\n                        return;\n                    }\n\n                    const ruleError = new RuleError(this.outputMessage(token), {\n                        index: token.index\n                    });\n                    report(lastHitNode, ruleError)\n                });\n            });\n        });\n    }\n\n    isOver() {\n        return this.dearuCount !== 0 && this.desumasuCount !== 0;\n    }\n\n    /**\n     * 優先するtypeを返します。\n     * @returns {*}\n     */\n    getOverType() {\n        if (this.options.preferDearu) {\n            return \"である\"\n        } else if (this.options.preferDesumasu) {\n            return \"ですます\";\n        }\n        if (this.dearuCount > this.desumasuCount) {\n            return \"である\";\n        } else {\n            return \"ですます\";\n        }\n    }\n\n    /**\n     * hist node list\n     * @param overType\n     * @returns {Array}\n     */\n    overHitList(overType) {\n        if (overType === \"である\") {\n            return this.desumasuHitList;\n        } else if (overType === \"ですます\") {\n            return this.dearuHitList;\n        }\n    }\n\n    /**\n     * create message string\n     * @param token\n     * @returns {string}\n     */\n    outputMessage(token) {\n        const overType = this.getOverType();\n        if (overType === \"である\") {\n            // である優先 => 最後の\"ですます\"を表示\n            return `\"である\"調 と \"ですます\"調 が混在\n=> \"${token.value}\" がですます調\nTotal:\nである  : ${this.dearuCount}\nですます: ${this.desumasuCount}\n`;\n        } else if (overType === \"ですます\") {\n            // ですます優先 => 最後の\"である\"を表示\n            return `\"である\"調 と \"ですます\"調 が混在\n=> \"${token.value}\" がである調\nTotal:\nである  : ${this.dearuCount}\nですます: ${this.desumasuCount}\n`;\n        }\n    }\n}\n"]}