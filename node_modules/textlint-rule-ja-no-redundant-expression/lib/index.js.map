{"version":3,"sources":["../src/index.js"],"names":["tokenize","require","dictionaryList","createMatchAll","replaceWithCaptureTokens","text","tokens","actualTokens","resultText","forEach","token","index","_capture","actualToken","replace","surface_form","reporter","context","Syntax","RuleError","report","fixer","getSource","matchAll","Str","node","then","matchResults","currentTokens","firstToken","matchResult","lastToken","length","firstWordIndex","Math","max","word_position","lastWorkIndex","message","dict","url","expected","undefined","fix","replaceTextRange","module","exports","linter"],"mappings":"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","file":"index.js","sourcesContent":["// MIT © 2016 azu\n\"use strict\";\nconst tokenize = require(\"kuromojin\").tokenize;\nconst dictionaryList = require(\"./dictionary\");\nconst createMatchAll = require(\"morpheme-match-all\");\nconst replaceWithCaptureTokens = (text, tokens, actualTokens) => {\n    let resultText = text;\n    tokens.forEach((token, index) => {\n        // _captureがないのは無視\n        if (!token._capture) {\n            return;\n        }\n        const actualToken = actualTokens[index];\n        resultText = resultText.replace(token._capture, actualToken.surface_form);\n    });\n    return resultText;\n};\nconst reporter = (context) => {\n    const {Syntax, RuleError, report, fixer, getSource} = context;\n    const matchAll = createMatchAll(dictionaryList);\n    return {\n        [Syntax.Str](node){\n            const text = getSource(node);\n            return tokenize(text).then(currentTokens => {\n                /**\n                 * @type {MatchResult[]}\n                 */\n                const matchResults = matchAll(currentTokens);\n                matchResults.forEach(matchResult => {\n                    const firstToken = matchResult.tokens[0];\n                    const lastToken = matchResult.tokens[matchResult.tokens.length - 1];\n                    const firstWordIndex = Math.max(firstToken.word_position - 1, 0);\n                    const lastWorkIndex = Math.max(lastToken.word_position - 1, 0);\n                    // replace $1\n                    const message = replaceWithCaptureTokens(matchResult.dict.message, matchResult.dict.tokens, matchResult.tokens)\n                        + (matchResult.dict.url ? `参考: ${matchResult.dict.url}` : \"\");\n                    const expected = matchResult.dict.expected\n                        ? replaceWithCaptureTokens(matchResult.dict.expected, matchResult.dict.tokens, matchResult.tokens)\n                        : undefined;\n                    if (expected) {\n                        report(node, new RuleError(message, {\n                            index: firstWordIndex,\n                            fix: fixer.replaceTextRange([\n                                firstWordIndex, lastWorkIndex + lastToken.surface_form.length\n                            ], expected)\n                        }));\n                    } else {\n                        report(node, new RuleError(message, {\n                            index: firstWordIndex\n                        }));\n                    }\n                });\n            });\n        }\n    }\n};\nmodule.exports = {\n    linter: reporter,\n    fixer: reporter\n};\n"]}