{"version":3,"sources":["../src/token-utils.js"],"names":["is助詞Token","token","test","pos","is読点Token","surface_form","concatToken","aToken","bToken","pos_detail_1","concatJoishiTokens","tokens","newTokens","forEach","prevToken","length","push","createKeyFromKey","restoreToSurfaceFromKey","key","split"],"mappings":"AAAA;AACA;AACA;;;;;AACO,IAAMA,gCAAY,SAAZA,SAAY,CAACC,KAAD,EAAW;AAChC;AACA,WAAOA,SAAS,MAAMC,IAAN,CAAWD,MAAME,GAAjB,CAAhB;AACH,CAHM;;AAKA,IAAMC,gCAAY,SAAZA,SAAY,CAACH,KAAD,EAAW;AAChC,WAAOA,MAAMI,YAAN,KAAuB,GAAvB,IAA8BJ,MAAME,GAAN,KAAc,IAAnD;AACH,CAFM;AAGP;;;;;;AAMA,IAAMG,cAAc,SAAdA,WAAc,CAACC,MAAD,EAASC,MAAT,EAAoB;AACpCD,WAAOF,YAAP,IAAuBG,OAAOH,YAA9B;AACAE,WAAOJ,GAAP,IAAcK,OAAOL,GAArB;AACAI,WAAOE,YAAP,IAAuBD,OAAOH,YAA9B;AACA,WAAOE,MAAP;AACH,CALD;AAMA;;;;;AAKO,IAAMG,kDAAqB,SAArBA,kBAAqB,CAACC,MAAD,EAAY;AAC1C,QAAMC,YAAY,EAAlB;AACAD,WAAOE,OAAP,CAAe,UAACZ,KAAD,EAAW;AACtB,YAAMa,YAAYF,UAAUA,UAAUG,MAAV,GAAmB,CAA7B,CAAlB;AACA,YAAIf,UAAUC,KAAV,KAAoBD,UAAUc,SAAV,CAAxB,EAA8C;AAC1CF,sBAAUA,UAAUG,MAAV,GAAmB,CAA7B,IAAkCT,YAAYQ,SAAZ,EAAuBb,KAAvB,CAAlC;AACH,SAFD,MAEO;AACHW,sBAAUI,IAAV,CAAef,KAAf;AACH;AACJ,KAPD;AAQA,WAAOW,SAAP;AACH,CAXM;AAYP;AACA;AACA;AACO,IAAMK,8CAAmB,SAAnBA,gBAAmB,CAAChB,KAAD,EAAW;AACvC;AACA,WAAUA,MAAMI,YAAhB,SAAgCJ,MAAME,GAAtC,SAA6CF,MAAMQ,YAAnD;AACH,CAHM;AAIP;AACO,IAAMS,4DAA0B,SAA1BA,uBAA0B,CAACC,GAAD,EAAS;AAC5C,WAAOA,IAAIC,KAAJ,CAAU,GAAV,EAAe,CAAf,CAAP;AACH,CAFM","file":"token-utils.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\n// 助詞どうか\nexport const is助詞Token = (token) => {\n    // 結合しているtokenは助詞助詞のようになってるため先頭一致で見る\n    return token && /^助詞/.test(token.pos);\n};\n\nexport const is読点Token = (token) => {\n    return token.surface_form === \"、\" && token.pos === \"名詞\";\n};\n/**\n * aTokenの_extraKeyに結合したkeyを追加する\n * @param {Object} aToken\n * @param {Object} bToken\n * @returns {Object}\n */\nconst concatToken = (aToken, bToken) => {\n    aToken.surface_form += bToken.surface_form;\n    aToken.pos += bToken.pos;\n    aToken.pos_detail_1 += bToken.surface_form;\n    return aToken;\n};\n/**\n * 助詞+助詞 というように連続しているtokenを結合し直したtokenの配列を返す\n * @param {Array} tokens\n * @returns {Array}\n */\nexport const concatJoishiTokens = (tokens) => {\n    const newTokens = [];\n    tokens.forEach((token) => {\n        const prevToken = newTokens[newTokens.length - 1];\n        if (is助詞Token(token) && is助詞Token(prevToken)) {\n            newTokens[newTokens.length - 1] = concatToken(prevToken, token);\n        } else {\n            newTokens.push(token);\n        }\n    });\n    return newTokens;\n};\n// 助詞tokenから品詞細分類1までを元にしたkeyを作る\n// http://www.unixuser.org/~euske/doc/postag/index.html#chasen\n// http://chasen.naist.jp/snapshot/ipadic/ipadic/doc/ipadic-ja.pdf\nexport const createKeyFromKey = (token) => {\n    // e.g.) \"は:助詞.係助詞\"\n    return `${token.surface_form}:${token.pos}.${token.pos_detail_1}`;\n};\n// keyからsurfaceを取り出す\nexport const restoreToSurfaceFromKey = (key) => {\n    return key.split(\":\")[0];\n};"]}