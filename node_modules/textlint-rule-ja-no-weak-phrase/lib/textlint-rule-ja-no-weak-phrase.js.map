{"version":3,"sources":["../src/textlint-rule-ja-no-weak-phrase.js"],"names":["tokenize","require","dictionaryList","createTokenMatcher","matchAll","module","exports","context","Syntax","RuleError","report","getSource","Str","node","text","then","matchResults","currentTokens","forEach","firstToken","matchResult","tokens","lastToken","length","firstWordIndex","Math","max","word_position","lastWorkIndex","message","dict","index"],"mappings":"AAAA;AACA;;;;AACA,IAAMA,WAAWC,QAAQ,WAAR,EAAqBD,QAAtC;AACA,IAAME,iBAAiBD,QAAQ,QAAR,CAAvB;AACA,IAAME,qBAAqBF,QAAQ,oBAAR,CAA3B;AACA,IAAMG,WAAWD,mBAAmBD,cAAnB,CAAjB;AACAG,OAAOC,OAAP,GAAiB,UAASC,OAAT,EAAkB;AAAA,QACvBC,MADuB,GACkBD,OADlB,CACvBC,MADuB;AAAA,QACfC,SADe,GACkBF,OADlB,CACfE,SADe;AAAA,QACJC,MADI,GACkBH,OADlB,CACJG,MADI;AAAA,QACIC,SADJ,GACkBJ,OADlB,CACII,SADJ;;AAE/B,+BACKH,OAAOI,GADZ,YACiBC,IADjB,EACuB;AACf,YAAMC,OAAOH,UAAUE,IAAV,CAAb;AACA,eAAOb,SAASc,IAAT,EAAeC,IAAf,CAAoB,yBAAiB;AACxC;;;AAGA,gBAAMC,eAAeZ,SAASa,aAAT,CAArB;AACAD,yBAAaE,OAAb,CAAqB,uBAAe;AAChC,oBAAMC,aAAaC,YAAYC,MAAZ,CAAmB,CAAnB,CAAnB;AACA,oBAAMC,YAAYF,YAAYC,MAAZ,CAAmBD,YAAYC,MAAZ,CAAmBE,MAAnB,GAA4B,CAA/C,CAAlB;AACA,oBAAMC,iBAAiBC,KAAKC,GAAL,CAASP,WAAWQ,aAAX,GAA2B,CAApC,EAAuC,CAAvC,CAAvB;AACA,oBAAMC,gBAAgBH,KAAKC,GAAL,CAASJ,UAAUK,aAAV,GAA0B,CAAnC,EAAsC,CAAtC,CAAtB;AACA;AACA,oBAAME,UAAUT,YAAYU,IAAZ,CAAiBD,OAAjC;AACAnB,uBAAOG,IAAP,EAAa,IAAIJ,SAAJ,CAAcoB,OAAd,EAAuB;AAChCE,2BAAOP;AADyB,iBAAvB,CAAb;AAGH,aAVD;AAWH,SAhBM,CAAP;AAiBH,KApBL;AAsBH,CAxBD","file":"textlint-rule-ja-no-weak-phrase.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst tokenize = require(\"kuromojin\").tokenize;\nconst dictionaryList = require(\"./dict\");\nconst createTokenMatcher = require(\"morpheme-match-all\");\nconst matchAll = createTokenMatcher(dictionaryList);\nmodule.exports = function(context) {\n    const { Syntax, RuleError, report, getSource } = context;\n    return {\n        [Syntax.Str](node) {\n            const text = getSource(node);\n            return tokenize(text).then(currentTokens => {\n                /**\n                 * @type {MatchResult[]}\n                 */\n                const matchResults = matchAll(currentTokens);\n                matchResults.forEach(matchResult => {\n                    const firstToken = matchResult.tokens[0];\n                    const lastToken = matchResult.tokens[matchResult.tokens.length - 1];\n                    const firstWordIndex = Math.max(firstToken.word_position - 1, 0);\n                    const lastWorkIndex = Math.max(lastToken.word_position - 1, 0);\n                    // replace $1\n                    const message = matchResult.dict.message;\n                    report(node, new RuleError(message, {\n                        index: firstWordIndex\n                    }));\n                });\n            });\n        }\n    }\n};"]}