{"version":3,"sources":["../src/morpheme-match.js"],"names":[],"mappings":";AACA;;AACA,SAAS,UAAT,CAAoB,KAApB,EAA2B,WAA3B,EAAwC;AACpC,WAAO,OAAO,IAAP,CAAY,WAAZ,EAAyB,KAAzB,CAA+B,eAAO;;AAEzC,YAAI,IAAI,CAAJ,MAAW,GAAf,EAAoB;AAChB,mBAAO,IAAP;AACH;AACD,YAAM,cAAc,MAAM,GAAN,CAApB;;;AAGA,YAAM,iBAAiB,MAAM,OAAN,CAAc,YAAY,GAAZ,CAAd,IAAkC,YAAY,GAAZ,CAAlC,GAAqD,CAAC,YAAY,GAAZ,CAAD,CAA5E;AACA,eAAO,eAAe,IAAf,CAAoB,yBAAiB;AACxC,mBAAO,gBAAgB,aAAvB;AACH,SAFM,CAAP;AAGH,KAZM,CAAP;AAaH;;;;;;;AAOD,OAAO,OAAP,GAAiB,SAAS,kBAAT,CAA4B,aAA5B,EAA2C;AACxD,QAAI,uBAAuB,CAA3B;AACA,QAAM,aAAa,cAAc,MAAjC;AACA,QAAM,cAAc,EAApB;AACA,WAAO,UAAC,KAAD,EAAW;AACd,YAAM,gBAAgB,cAAc,oBAAd,CAAtB;AACA,YAAI,WAAW,KAAX,EAAkB,aAAlB,CAAJ,EAAsC;AAClC,wBAAY,IAAZ,CAAiB,KAAjB;AACA,oCAAwB,CAAxB;AACH,SAHD,MAGO;;AAEH,wBAAY,MAAZ,GAAqB,CAArB;AACA,mCAAuB,CAAvB;AACH;;AAED,YAAI,yBAAyB,UAA7B,EAAyC;AACrC,gBAAM,SAAS,YAAY,KAAZ,EAAf;;AAEA,mCAAuB,CAAvB;AACA,wBAAY,MAAZ,GAAqB,CAArB;AACA,mBAAO;AACH,uBAAO,IADJ;AAEH,wBAAQ;AAFL,aAAP;AAIH;AACD,eAAO;AACH,mBAAO;AADJ,SAAP;AAGH,KAxBD;AAyBH,CA7BD","file":"morpheme-match.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nfunction matchToken(token, expectShape) {\n    return Object.keys(expectShape).every(key => {\n        // Ignore start with _ key\n        if (key[0] === \"_\") {\n            return true;\n        }\n        const actualValue = token[key];\n        // support multiple value\n        // \"pos\": [\"名詞\", \"副詞\"]\n        const expectedValues = Array.isArray(expectShape[key]) ? expectShape[key] : [expectShape[key]];\n        return expectedValues.some(expectedValue => {\n            return actualValue === expectedValue;\n        });\n    })\n}\n\n/**\n * Create matcher function that return { match : true , tokens []} if match the `token`.\n * @param {Object[]} matchedTokens\n * @returns {function(token:Object)}\n */\nmodule.exports = function createTokenMatcher(matchedTokens) {\n    let currentTokenPosition = 0;\n    const tokenCount = matchedTokens.length;\n    const matchTokens = [];\n    return (token) => {\n        const expectedToken = matchedTokens[currentTokenPosition];\n        if (matchToken(token, expectedToken)) {\n            matchTokens.push(token);\n            currentTokenPosition += 1;\n        } else {\n            // reset position\n            matchTokens.length = 0;\n            currentTokenPosition = 0;\n        }\n        // match all tokens\n        if (currentTokenPosition === tokenCount) {\n            const tokens = matchTokens.slice();\n            // match -> reset\n            currentTokenPosition = 0;\n            matchTokens.length = 0;\n            return {\n                match: true,\n                tokens: tokens\n            };\n        }\n        return {\n            match: false\n        };\n    }\n};"]}