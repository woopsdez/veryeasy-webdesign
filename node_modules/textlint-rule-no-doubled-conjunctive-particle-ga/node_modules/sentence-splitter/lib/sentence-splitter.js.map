{"version":3,"sources":["../src/sentence-splitter.js"],"names":[],"mappings":";AACA,YAAY,CAAC;;;;;;kBAUW,cAAc;QAwDtB,oBAAoB,GAApB,oBAAoB;QASpB,kBAAkB,GAAlB,kBAAkB;;;;;;;;AAzElC,IAAM,cAAc,GAAG;AACnB,cAAU,EAAE,aAAa;AACzB,qBAAiB,EAAE,IAAI;CAC1B,CAAC;AACK,IAAM,MAAM,WAAN,MAAM,GAAG;AAClB,gBAAY,EAAE,YAAY;AAC1B,cAAU,EAAE,UAAU;CACzB,CAAC;AACa,SAAS,cAAc,CAAC,IAAI,EAAgB;QAAd,OAAO,yDAAG,EAAE;;AACrD,QAAM,SAAS,GAAG,OAAO,CAAC,UAAU,IAAI,cAAc,CAAC,UAAU,CAAC;AAClE,QAAM,iBAAiB,GAAG,OAAO,CAAC,iBAAiB,IAAI,cAAc,CAAC,iBAAiB,CAAC;AACxF,QAAM,GAAG,GAAG,+BAAoB,IAAI,CAAC,CAAC;AACtC,QAAI,UAAU,GAAG,SAAb,UAAU,CAAI,IAAI,EAAE,KAAK,EAAE,GAAG,EAAI;AAClC,YAAI,KAAK,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AACzB,YAAI,QAAQ,GAAG,GAAG,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;AAC1C,YAAI,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AACxC,YAAI,IAAI,YAAA,CAAC;AACT,YAAI,IAAI,KAAK,MAAM,CAAC,UAAU,EAAE;AAC5B,gBAAI,GAAG,oBAAoB,CAAC,UAAU,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;SAC5D,MAAM,IAAI,IAAI,KAAK,MAAM,CAAC,QAAQ,EAAE;AACjC,gBAAI,GAAG,kBAAkB,CAAC,UAAU,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;SAC1D;AACD,eAAO,IAAI,CAAC;KACf,CAAC;AACF,QAAI,OAAO,GAAG,EAAE,CAAC;AACjB,QAAI,UAAU,GAAG,CAAC,CAAC;AACnB,QAAI,YAAY,GAAG,CAAC,CAAC;AACrB,QAAI,YAAY,GAAG,KAAK,CAAC;AACzB,QAAM,uBAAuB,GAAG,iBAAiB,CAAC,MAAM,CAAC;AACzD,WAAO,YAAY,GAAG,IAAI,CAAC,MAAM,EAAE,YAAY,EAAE,EAAE;AAC/C,YAAI,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC;AAC9B,YAAI,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,EAAE,YAAY,GAAG,uBAAuB,CAAC,CAAC;AACnF,YAAI,WAAW,KAAK,iBAAiB,EAAE;;AAEnC,gBAAI,UAAU,KAAK,YAAY,EAAE;AAC7B,uBAAO,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC,CAAC;aACvE;AACD,iBAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,uBAAuB,EAAE,CAAC,EAAE,EAAE;;AAE9C,oBAAI,UAAU,GAAG,YAAY,GAAG,CAAC,CAAC;AAClC,uBAAO,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;aAC3E;;AAAA,AAED,sBAAU,GAAG,YAAY,GAAG,uBAAuB,CAAC;AACpD,wBAAY,GAAG,KAAK,CAAC;SACxB,MAAM,IAAI,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AAC7B,wBAAY,GAAG,IAAI,CAAC;SACvB,MAAM;;;AAGH,gBAAI,YAAY,EAAE;AACd,uBAAO,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;;AAAC,AAEpE,0BAAU,GAAG,YAAY,CAAC;AAC1B,4BAAY,GAAG,KAAK,CAAC;aACxB;SACJ;KACJ;;AAED,QAAI,UAAU,KAAK,YAAY,EAAE;AAC7B,eAAO,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC,CAAC;KACvE;AACD,WAAO,OAAO,CAAC;CAClB;AACM,SAAS,oBAAoB,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE;AACnD,WAAO;AACH,YAAI,EAAE,YAAY;AAClB,WAAG,EAAE,IAAI;AACT,aAAK,EAAE,IAAI;AACX,WAAG,EAAE,GAAG;AACR,aAAK,EAAE,KAAK;KACf,CAAA;CACJ;AACM,SAAS,kBAAkB,CAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAE;AACjD,WAAO;AACH,YAAI,EAAE,UAAU;AAChB,WAAG,EAAE,IAAI;AACT,aAAK,EAAE,IAAI;AACX,WAAG,EAAE,GAAG;AACR,aAAK,EAAE,KAAK;KACf,CAAA;CACJ","file":"sentence-splitter.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport StructureSource from \"structured-source\";\nconst defaultOptions = {\n    charRegExp: /[\\.。\\?\\!？！]/,\n    newLineCharacters: \"\\n\"\n};\nexport const Syntax = {\n    \"WhiteSpace\": \"WhiteSpace\",\n    \"Sentence\": \"Sentence\"\n};\nexport default function splitSentences(text, options = {}) {\n    const matchChar = options.charRegExp || defaultOptions.charRegExp;\n    const newLineCharacters = options.newLineCharacters || defaultOptions.newLineCharacters;\n    const src = new StructureSource(text);\n    let createNode = (type, start, end)=> {\n        let range = [start, end];\n        let location = src.rangeToLocation(range);\n        let slicedText = text.slice(start, end);\n        let node;\n        if (type === Syntax.WhiteSpace) {\n            node = createWhiteSpaceNode(slicedText, location, range);\n        } else if (type === Syntax.Sentence) {\n            node = createSentenceNode(slicedText, location, range);\n        }\n        return node;\n    };\n    let results = [];\n    let startPoint = 0;\n    let currentIndex = 0;\n    let isSplitPoint = false;\n    const newLineCharactersLength = newLineCharacters.length;\n    for (; currentIndex < text.length; currentIndex++) {\n        let char = text[currentIndex];\n        let whiteTarget = text.slice(currentIndex, currentIndex + newLineCharactersLength);\n        if (whiteTarget === newLineCharacters) {\n            // (string)\\n\n            if (startPoint !== currentIndex) {\n                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n            }\n            for (let i = 0; i < newLineCharactersLength; i++) {\n                // string(\\n)\n                let startIndex = currentIndex + i;\n                results.push(createNode(Syntax.WhiteSpace, startIndex, startIndex + 1));\n            }\n            // string\\n|\n            startPoint = currentIndex + newLineCharactersLength;\n            isSplitPoint = false;\n        } else if (matchChar.test(char)) {\n            isSplitPoint = true;\n        } else {\n            // why `else`\n            // it for support 。。。 pattern\n            if (isSplitPoint) {\n                results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n                // reset stat\n                startPoint = currentIndex;\n                isSplitPoint = false;\n            }\n        }\n    }\n\n    if (startPoint !== currentIndex) {\n        results.push(createNode(Syntax.Sentence, startPoint, currentIndex));\n    }\n    return results;\n}\nexport function createWhiteSpaceNode(text, loc, range) {\n    return {\n        type: \"WhiteSpace\",\n        raw: text,\n        value: text,\n        loc: loc,\n        range: range\n    }\n}\nexport function createSentenceNode(text, loc, range) {\n    return {\n        type: \"Sentence\",\n        raw: text,\n        value: text,\n        loc: loc,\n        range: range\n    }\n}"]}