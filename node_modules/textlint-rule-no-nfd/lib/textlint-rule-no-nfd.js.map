{"version":3,"sources":["../src/textlint-rule-no-nfd.js"],"names":[],"mappings":";AACA;;AACA;;AACA;;;;AACA,IAAM,QAAQ,QAAQ,OAAR,CAAd;AACA,SAAS,QAAT,CAAkB,OAAlB,EAA2B;AAAA,QAChB,MADgB,GAC+B,OAD/B,CAChB,MADgB;AAAA,QACR,SADQ,GAC+B,OAD/B,CACR,SADQ;AAAA,QACG,MADH,GAC+B,OAD/B,CACG,MADH;AAAA,QACW,KADX,GAC+B,OAD/B,CACW,KADX;AAAA,QACkB,SADlB,GAC+B,OAD/B,CACkB,SADlB;;AAEvB,QAAM,SAAS,mCAAe,OAAf,CAAf;AACA,+BACK,OAAO,GADZ,YACiB,IADjB,EACsB;AACd,YAAI,OAAO,WAAP,CAAmB,IAAnB,EAAyB,CAAC,OAAO,IAAR,EAAc,OAAO,KAArB,EAA4B,OAAO,UAAnC,EAA+C,OAAO,QAAtD,CAAzB,CAAJ,EAA+F;AAC3F;AACH;AACD,YAAM,OAAO,UAAU,IAAV,CAAb;AACA,8CAAqB,IAArB,EAA2B,+BAA3B,EAA4D,OAA5D,CAAoE,gBAAa;AAAA,gBAAX,KAAW,QAAX,KAAW;;AAC7E,gBAAI,UAAU,CAAd,EAAiB;AACb;AACH;;AAED,gBAAM,eAAe,KAAK,KAAL,CAAW,QAAQ,CAAnB,EAAsB,QAAQ,CAA9B,CAArB;AACA,gBAAM,WAAW,aAAa,OAAb,CAAqB,GAArB,EAA+B,GAA/B,EAAyC,OAAzC,CAAiD,GAAjD,EAA2D,GAA3D,CAAjB;AACA,gBAAM,eAAe,MAAM,GAAN,CAAU,QAAV,CAArB;AACA,gBAAM,YAAY,IAAI,SAAJ,wDAAkE,YAAlE,gBAAuF,YAAvF,SAAwG;AACtH,4BADsH;AAEtH,qBAAK,MAAM,gBAAN,CAAuB,CAAC,QAAQ,CAAT,EAAY,QAAQ,CAApB,CAAvB,EAA+C,YAA/C;AAFiH,aAAxG,CAAlB;AAIA,mBAAO,IAAP,EAAa,SAAb;AACH,SAbD;AAcH,KApBL;AAsBH;AACD,OAAO,OAAP,GAAiB;AACb,YAAQ,QADK;AAEb,WAAO;AAFM,CAAjB","file":"textlint-rule-no-nfd.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport {RuleHelper} from \"textlint-rule-helper\";\nimport {matchCaptureGroupAll} from \"match-index\"\nconst unorm = require(\"unorm\");\nfunction reporter(context) {\n    const {Syntax, RuleError, report, fixer, getSource} = context;\n    const helper = new RuleHelper(context);\n    return {\n        [Syntax.Str](node){\n            if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {\n                return;\n            }\n            const text = getSource(node);\n            matchCaptureGroupAll(text, /([\\u309b\\u309c\\u309a\\u3099])/g).forEach(({index}) => {\n                if (index === 0) {\n                    return;\n                }\n                // \\u309b\\u309c => \\u309a\\u3099\n                const dakutenChars = text.slice(index - 1, index + 1);\n                const nfdlized = dakutenChars.replace(\"\\u309B\", \"\\u3099\").replace(\"\\u309C\", \"\\u309A\");\n                const expectedText = unorm.nfc(nfdlized);\n                const ruleError = new RuleError(`Disallow to use NFD(well-known as UTF8-MAC 濁点): \"${dakutenChars}\" => \"${expectedText}\"`, {\n                    index,\n                    fix: fixer.replaceTextRange([index - 1, index + 1], expectedText)\n                });\n                report(node, ruleError);\n            });\n        }\n    }\n}\nmodule.exports = {\n    linter: reporter,\n    fixer: reporter\n};"]}