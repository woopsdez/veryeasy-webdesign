// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

var _matchIndex = require("match-index");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var unorm = require("unorm");
function reporter(context) {
    var Syntax = context.Syntax;
    var RuleError = context.RuleError;
    var report = context.report;
    var fixer = context.fixer;
    var getSource = context.getSource;

    var helper = new _textlintRuleHelper.RuleHelper(context);
    return _defineProperty({}, Syntax.Str, function (node) {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
            return;
        }
        var text = getSource(node);
        (0, _matchIndex.matchCaptureGroupAll)(text, /([\u309b\u309c\u309a\u3099])/g).forEach(function (_ref) {
            var index = _ref.index;

            if (index === 0) {
                return;
            }
            // \u309b\u309c => \u309a\u3099
            var dakutenChars = text.slice(index - 1, index + 1);
            var nfdlized = dakutenChars.replace("゛", "゙").replace("゜", "゚");
            var expectedText = unorm.nfc(nfdlized);
            var ruleError = new RuleError("Disallow to use NFD(well-known as UTF8-MAC 濁点): \"" + dakutenChars + "\" => \"" + expectedText + "\"", {
                index: index,
                fix: fixer.replaceTextRange([index - 1, index + 1], expectedText)
            });
            report(node, ruleError);
        });
    });
}
module.exports = {
    linter: reporter,
    fixer: reporter
};
//# sourceMappingURL=textlint-rule-no-nfd.js.map