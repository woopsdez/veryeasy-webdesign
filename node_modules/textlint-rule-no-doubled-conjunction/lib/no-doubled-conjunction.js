// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

/*
    1. Paragraph Node -> text
    2. text -> sentences
    3. tokenize sentence
    4. report error if found word that match the rule.

    TODO: need abstraction
 */


exports.default = function (context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var helper = new _textlintRuleHelper.RuleHelper(context);
    var Syntax = context.Syntax;
    var report = context.report;
    var getSource = context.getSource;
    var RuleError = context.RuleError;

    return _defineProperty({}, Syntax.Paragraph, function (node) {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
            return;
        }
        var source = new _textlintUtilToString2.default(node);
        var text = source.toString();
        var isSentenceNode = function isSentenceNode(node) {
            return node.type === _sentenceSplitter.Syntax.Sentence;
        };
        var sentences = (0, _sentenceSplitter.split)(text, {
            charRegExp: /[。\?\!？！]/
        }).filter(isSentenceNode);
        // if not have a sentence, early return
        // It is for avoiding error of emptyArray.reduce().
        if (sentences.length === 0) {
            return;
        }
        return (0, _kuromojin.getTokenizer)().then(function (tokenizer) {
            var selectConjenction = function selectConjenction(sentence) {
                var tokens = tokenizer.tokenizeForSentence(sentence.raw);
                var conjunctionTokens = tokens.filter(function (token) {
                    return token.pos === "接続詞";
                });
                return [sentence, conjunctionTokens];
            };
            var prev_token = null;
            sentences.map(selectConjenction).reduce(function (prev, current) {
                var token = prev_token;

                var _current = _slicedToArray(current, 2);

                var sentence = _current[0];
                var current_tokens = _current[1];

                var _prev = _slicedToArray(prev, 2);

                var prev_sentence = _prev[0];
                var prev_tokens = _prev[1];

                if (prev_tokens && prev_tokens.length > 0) {
                    token = prev_tokens[0];
                }
                if (current_tokens.length > 0) {
                    if (token && current_tokens[0].surface_form === token.surface_form) {
                        var originalIndex = source.originalIndexFromPosition({
                            line: sentence.loc.start.line,
                            column: sentence.loc.start.column + (current_tokens[0].word_position - 1)
                        });
                        // padding position
                        var padding = {
                            index: originalIndex
                        };
                        report(node, new RuleError("同じ接続詞が連続して使われています。", padding));
                    }
                }
                prev_token = token;
                return current;
            });
        });
    });
};

var _textlintRuleHelper = require("textlint-rule-helper");

var _kuromojin = require("kuromojin");

var _sentenceSplitter = require("sentence-splitter");

var _textlintUtilToString = require("textlint-util-to-string");

var _textlintUtilToString2 = _interopRequireDefault(_textlintUtilToString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

;
module.exports = exports["default"];
//# sourceMappingURL=no-doubled-conjunction.js.map