// MIT Â© 2017 azu
"use strict";

var _CONTROL_CHARACTERS = require("./CONTROL_CHARACTERS");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var execall = require("execall");


/**
 * Convert char to \uXXXX
 * @param {string} str
 * @return {string}
 */
var unicodeEscape = function unicodeEscape(str) {
    return str.replace(/./g, function (c) {
        return "\\u" + ("000" + c.charCodeAt(0).toString(16)).substr(-4);
    });
};

var getName = function getName(char) {
    var matchChar = _CONTROL_CHARACTERS.CONTROL_CHARACTERS.find(function (CONTROL_CHARACTER) {
        return CONTROL_CHARACTER.code === char;
    });
    if (!matchChar) {
        return "";
    }
    return matchChar.name;
};

var DEFAULT_OPTION = {
    // Define allow char code like `\u0019`
    allow: [],
    // Check code if it is true
    checkCode: false
};

var reporter = function reporter(context) {
    var _ref;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var Syntax = context.Syntax,
        RuleError = context.RuleError,
        getSource = context.getSource,
        fixer = context.fixer,
        report = context.report;

    var allow = options.allow || DEFAULT_OPTION.allow;
    var checkCode = options.checkCode !== undefined ? options.checkCode : DEFAULT_OPTION.checkCode;
    var checkNode = function checkNode(node) {
        var text = getSource(node);
        // Ignore \r \n \t
        var controlCharacterPattern = /([\x00-\x08\x0B\x0C\x0E-\x1F\x7F])/g;
        /**
         * @type {Array<{match:string, sub:string[], index:number}>}
         */
        var results = execall(controlCharacterPattern, text);
        results.forEach(function (result) {
            var index = result.index;
            var char = result.sub[0];
            // if allow the `char`, ignore it
            if (allow.some(function (allowChar) {
                return allowChar === char;
            })) {
                return;
            }
            var name = getName(char);
            var ruleError = new RuleError("Found invalid control character(" + name + " " + unicodeEscape(char) + ")", {
                index: index,
                fix: fixer.removeRange([index, index + 1])
            });
            report(node, ruleError);
        });
    };
    return _ref = {}, _defineProperty(_ref, Syntax.Str, function (node) {
        checkNode(node);
    }), _defineProperty(_ref, Syntax.CodeBlock, function (node) {
        if (checkCode) {
            checkNode(node);
        }
    }), _defineProperty(_ref, Syntax.Code, function (node) {
        if (checkCode) {
            checkNode(node);
        }
    }), _ref;
};

module.exports = {
    linter: reporter,
    fixer: reporter
};
//# sourceMappingURL=textlint-rule-no-invalid-control-character.js.map