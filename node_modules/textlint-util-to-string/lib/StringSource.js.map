{"version":3,"sources":["../src/StringSource.js"],"names":[],"mappings":"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","file":"StringSource.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport ObjectAssign from \"object-assign\";\nimport StructuredSource from \"structured-source\";\nexport default class StringSource {\n    constructor(node) {\n        this.rootNode = node;\n        this.tokenMaps = [];\n        this.generatedString = \"\";\n        // pre calculate\n        this._stringify(this.rootNode);\n        this.originalSource = new StructuredSource(this.rootNode.raw);\n        this.generatedSource = new StructuredSource(this.generatedString);\n        /*\n         [\n         // e.g.) **Str**\n         {\n         // original range\n         // e.g.) [0, 7] = `**Str**`\n         original : [start, end]\n         // intermediate = trim decoration from Original\n         // e.g.) [2, 5]\n         intermediate: [start, end]\n         // generaged value = \"Str\"\n         // e.g.) [0, 3]\n         generated : [start, end]\n         }]\n         */\n    }\n\n    toString() {\n        return this.generatedString;\n    }\n\n    /**\n     * @deprecated use originalIndexFromIndex instead of\n     * @param targetIndex\n     */\n    originalIndexFor(targetIndex) {\n        return this.originalIndexFromIndex(targetIndex);\n    }\n\n    /**\n     * @deprecated use originalPositionFromPosition instead of\n     * @param generatedPosition\n     * @returns {Object}\n     */\n    originalPositionFor(generatedPosition) {\n        return this.originalPositionFromPosition(generatedPosition);\n    }\n\n    /**\n     * get original index from generated index value\n     * @param {number} generatedIndex - position is a index value.\n     * @returns {number|undefined} original\n     */\n    originalIndexFromIndex(generatedIndex) {\n        let hitTokenMaps = this.tokenMaps.filter(tokenMap => {\n            let generated = tokenMap.generated;\n            if (generated[0] <= generatedIndex && generatedIndex < generated[1]) {\n                return true;\n            }\n        });\n        if (hitTokenMaps.length === 0) {\n            return;\n        }\n        // a bcd\n        // b = index 1\n        // original `a` bcd\n        // originalRange [3, 7]\n        // adjustedStart = 1\n        // b's index = 3 + 1\n        let hitTokenMap = hitTokenMaps[0];\n        // <----------->\\[<------------->|text]\n        //              ^        ^\n        //   position-generated  intermediate-origin\n        let outAdjust = generatedIndex - hitTokenMap.generated[0];\n        let inAdjust = hitTokenMap.intermediate[0] - hitTokenMap.original[0];\n        return outAdjust + inAdjust + hitTokenMap.original[0];\n    }\n\n    /**\n     * get original position from generated position\n     * @param {object} position\n     * @returns {object} original position\n     */\n    originalPositionFromPosition(position) {\n        if (typeof position.line === \"undefined\" || typeof position.column === \"undefined\") {\n            throw new Error(\"position.{line, column} should not undefined: \" + JSON.stringify(position));\n        }\n        var generatedIndex = this.generatedSource.positionToIndex(position);\n        if (isNaN(generatedIndex)) {\n            // Not Found\n            return;\n        }\n        let originalIndex = this.originalIndexFromIndex(generatedIndex);\n        return this.originalSource.indexToPosition(originalIndex);\n    }\n\n    /**\n     * get original index from generated position\n     * @param {object} generatedPosition\n     * @returns {number} original index\n     */\n    originalIndexFromPosition(generatedPosition) {\n        const originalPosition = this.originalPositionFromPosition(generatedPosition);\n        return this.originalSource.positionToIndex(originalPosition);\n    }\n\n    /**\n     * get original position from generated index\n     * @param {number} generatedIndex\n     * @return {object} original position\n     */\n    originalPositionFromIndex(generatedIndex) {\n        let originalIndex = this.originalIndexFromIndex(generatedIndex);\n        return this.originalSource.indexToPosition(originalIndex);\n    }\n\n\n    isParagraphNode(node) {\n        return node.type === \"Paragraph\";\n    }\n\n    isStringNode(node) {\n        return node.type === \"Str\";\n    }\n\n    _getValue(node) {\n        if (node.value) {\n            return node.value;\n        } else if (node.alt) {\n            return node.alt;\n        } else if (node.title) {\n            return node.title;\n        }\n    }\n\n    _nodeRangeAsRelative(node) {\n        // relative from root\n        return [\n            node.range[0] - this.rootNode.range[0],\n            node.range[1] - this.rootNode.range[0]\n        ]\n    }\n\n    _valueOf(node, parent) {\n        if (!node) {\n            return;\n        }\n\n\n        // [padding][value][padding]\n        // =>\n        // [value][value][value]\n        let value = this._getValue(node);\n        if (!value) {\n            return;\n        }\n        if (parent == null) {\n            return;\n        }\n        // <p><Str /></p>\n        if (this.isParagraphNode(parent) && this.isStringNode(node)) {\n            return {\n                original: this._nodeRangeAsRelative(node),\n                intermediate: this._nodeRangeAsRelative(node),\n                value: value\n            };\n        }\n        // <p><code>code</code></p>\n        // => container is <p>\n        // <p><strong><Str /></strong></p>\n        // => container is <strong>\n        let container = this.isParagraphNode(parent) ? node : parent;\n        let rawValue = container.raw;\n        // avoid match ! with ![\n        // TODO: indexOf(value, 1) 1 is unexpected ...\n        let paddingLeft = rawValue.indexOf(value, 1) === -1 ? 0 : rawValue.indexOf(value, 1);\n        let paddingRight = rawValue.length - (paddingLeft + value.length);\n        // original range should be relative value from rootNode\n        let originalRange = this._nodeRangeAsRelative(container);\n        let intermediateRange = [\n            originalRange[0] + paddingLeft,\n            originalRange[1] - paddingRight\n        ];\n        return {\n            original: originalRange,\n            intermediate: intermediateRange,\n            value: value\n        };\n\n    }\n\n    _addTokenMap(tokenMap) {\n        if (tokenMap == null) {\n            return;\n        }\n        let addedTokenMap = ObjectAssign({}, tokenMap);\n        if (this.tokenMaps.length === 0) {\n            let textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];\n            addedTokenMap[\"generated\"] = [0, textLength];\n        } else {\n            let textLength = addedTokenMap.intermediate[1] - addedTokenMap.intermediate[0];\n            addedTokenMap[\"generated\"] = [this.generatedString.length, this.generatedString.length + textLength];\n        }\n        this.generatedString += tokenMap.value;\n        this.tokenMaps.push(addedTokenMap);\n    }\n\n    /**\n     * Compute text content of a node.  If the node itself\n     * does not expose plain-text fields, `toString` will\n     * recursivly try its children.\n     *\n     * @param {Node} node - Node to transform to a string.\n     * @param {Node} [parent] - Parent Node of the `node`.\n     */\n    _stringify(node, parent) {\n        let value = this._valueOf(node, parent);\n        if (value) {\n            return value;\n        }\n        if (!node.children) {\n            return;\n        }\n        node.children.forEach((childNode) => {\n            let tokenMap = this._stringify(childNode, node);\n            if (tokenMap) {\n                this._addTokenMap(tokenMap);\n            }\n        });\n    }\n}\n"]}