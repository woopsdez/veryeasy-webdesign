// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var prh = require("prh");
var path = require("path");
var untildify = require('untildify');
function createPrhEngine(rulePaths, baseDir) {
    if (rulePaths.length === 0) {
        return null;
    }
    var expandedRulePaths = rulePaths.map(function (rulePath) {
        return untildify(rulePath);
    });
    var prhEngine = prh.fromYAMLFilePath(path.resolve(baseDir, expandedRulePaths[0]));
    expandedRulePaths.slice(1).forEach(function (ruleFilePath) {
        var config = prh.fromYAMLFilePath(path.resolve(baseDir, ruleFilePath));
        prhEngine.merge(config);
    });
    return prhEngine;
}
function createPrhEngineFromContents(yamlContents) {
    if (yamlContents.length === 0) {
        return null;
    }
    var prhEngine = prh.fromYAML(null, yamlContents[0]);
    yamlContents.slice(1).forEach(function (content) {
        var config = prh.fromYAML(null, content);
        prhEngine.merge(config);
    });
    return prhEngine;
}
function mergePrh() {
    for (var _len = arguments.length, engines = Array(_len), _key = 0; _key < _len; _key++) {
        engines[_key] = arguments[_key];
    }

    var engines_ = engines.filter(function (engine) {
        return !!engine;
    });
    var mainEngine = engines_[0];
    engines_.slice(1).forEach(function (engine) {
        mainEngine.merge(engine);
    });
    return mainEngine;
}
var assertOptions = function assertOptions(options) {
    if (typeof options.ruleContents === "undefined" && typeof options.rulePaths === "undefined") {
        throw new Error("textlint-rule-prh require Rule Options.\nPlease set .textlinrc:\n{\n    \"rules\": {\n        \"prh\": {\n            \"rulePaths\" :[\"path/to/prh.yml\"]\n        }\n    }\n}\n");
    }
};

/**
 * for each diff of changeSet
 * @param {ChangeSet} changeSet
 * @param {string} str
 * @param {function({
            matchStartIndex: number,
            matchEndIndex: number,
            actual: string
            expected: string
        })}onChangeOfMatch
 */
var forEachChange = function forEachChange(changeSet, str, onChangeOfMatch) {
    var sortedDiffs = changeSet.diffs.sort(function (a, b) {
        return a.index - b.index;
    });
    var delta = 0;
    sortedDiffs.forEach(function (diff) {
        var result = diff.expected.replace(/\$([0-9]{1,2})/g, function (match, g1) {
            var index = parseInt(g1);
            if (index === 0 || diff.matches.length - 1 < index) {
                return match;
            }
            return diff.matches[index] || "";
        });
        // matchStartIndex/matchEndIndex value is original position, not replaced position
        // textlint use original position
        var matchStartIndex = diff.index;
        var matchEndIndex = matchStartIndex + diff.matches[0].length;
        // actual => expected
        var actual = str.slice(diff.index + delta, diff.index + delta + diff.matches[0].length);
        onChangeOfMatch({
            matchStartIndex: matchStartIndex,
            matchEndIndex: matchEndIndex,
            actual: actual,
            expected: result
        });
        str = str.slice(0, diff.index + delta) + result + str.slice(diff.index + delta + diff.matches[0].length);
        delta += result.length - diff.matches[0].length;
    });
};
function reporter(context) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    assertOptions(options);
    var textlintRcFilePath = context.config ? context.config.configFile : null;
    // .textlinrc directory
    var textlintRCDir = textlintRcFilePath ? path.dirname(textlintRcFilePath) : process.cwd();
    // create prh config
    var rulePaths = options.rulePaths || [];
    var ruleContents = options.ruleContents || [];
    // yaml file + yaml contents
    var prhEngineContent = createPrhEngineFromContents(ruleContents);
    var prhEngineFiles = createPrhEngine(rulePaths, textlintRCDir);
    var prhEngine = mergePrh(prhEngineFiles, prhEngineContent);
    var helper = new _textlintRuleHelper.RuleHelper(context);
    var Syntax = context.Syntax,
        getSource = context.getSource,
        report = context.report,
        fixer = context.fixer,
        RuleError = context.RuleError;

    return _defineProperty({}, Syntax.Str, function (node) {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
            return;
        }
        var text = getSource(node);
        // to get position from index
        var makeChangeSet = prhEngine.makeChangeSet(null, text);
        forEachChange(makeChangeSet, text, function (_ref) {
            var matchStartIndex = _ref.matchStartIndex,
                matchEndIndex = _ref.matchEndIndex,
                actual = _ref.actual,
                expected = _ref.expected;

            // If result is not changed, should not report
            if (actual === expected) {
                return;
            }
            report(node, new RuleError(actual + " => " + expected, {
                index: matchStartIndex,
                fix: fixer.replaceTextRange([matchStartIndex, matchEndIndex], expected)
            }));
        });
    });
}
module.exports = {
    linter: reporter,
    fixer: reporter
};
//# sourceMappingURL=prh-rule.js.map