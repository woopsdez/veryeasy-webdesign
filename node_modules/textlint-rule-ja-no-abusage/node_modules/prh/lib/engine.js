"use strict";
var fs = require("fs");
var r = require("./utils/regexp");
var target_1 = require("./target");
var rule_1 = require("./rule");
var changeSet = require("./changeset");
var Engine = (function () {
    function Engine(src) {
        if (!src) {
            throw new Error("src is requried");
        }
        this.version = +src.version || 1;
        this.targets = (src.targets || []).map(function (target) { return new target_1.default(target); });
        this.rules = (src.rules || []).map(function (rule) { return new rule_1.default(rule); });
    }
    Engine.prototype.merge = function (other) {
        var _this = this;
        if (!other) {
            throw new Error("other is required");
        }
        if (this.version !== other.version) {
            throw new Error("version mismatch!");
        }
        other.targets.forEach(function (otherTarget) {
            var exists = _this.targets.filter(function (target) { return r.equals(target.file, otherTarget.file); }).length !== 0;
            if (!exists) {
                _this.targets.push(otherTarget);
            }
        });
        // NOTE https://github.com/vvakame/prh/issues/18#issuecomment-222524140
        var reqRules = other.rules.filter(function (otherRule) {
            return _this.rules.filter(function (rule) { return rule.expected === otherRule.expected; }).length === 0;
        });
        this.rules = this.rules.concat(reqRules);
    };
    Engine.prototype.makeChangeSet = function (filePath, contentArg) {
        var content = contentArg != null ? contentArg : fs.readFileSync(filePath, { encoding: "utf8" });
        var changeSets = new changeSet.ChangeSet();
        this.rules.forEach(function (rule) {
            var set = rule.applyRule(content);
            changeSets = changeSets.concat(set);
        });
        var includes = new changeSet.ChangeSet();
        var excludes = new changeSet.ChangeSet();
        var includesExists = false;
        var excludesExists = false;
        this.targets.forEach(function (target) {
            target.reset();
            if (!target.file.test(filePath)) {
                return;
            }
            if (target.includes.length !== 0) {
                // .ts の // の後や /* */ の内部だけ対象にしたい場合のための機能
                includesExists = true;
                target.includes.forEach(function (include) {
                    includes = includes.concat(changeSet.makeChangeSet(content, include.pattern, null));
                });
            }
            if (target.excludes.length !== 0) {
                // .re の #@ の後を対象にしたくない場合のための機能
                excludesExists = true;
                target.excludes.forEach(function (exclude) {
                    excludes = excludes.concat(changeSet.makeChangeSet(content, exclude.pattern, null));
                });
            }
        });
        if (includesExists) {
            changeSets = changeSets.intersect(includes);
        }
        if (excludesExists) {
            changeSets = changeSets.subtract(excludes);
        }
        return changeSets;
    };
    Engine.prototype.replaceByRule = function (filePath, content) {
        if (content == null) {
            content = fs.readFileSync(filePath, { encoding: "utf8" });
        }
        var changeSets = this.makeChangeSet(filePath, content);
        return changeSets.applyChangeSets(content);
    };
    return Engine;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Engine;
//# sourceMappingURL=engine.js.map