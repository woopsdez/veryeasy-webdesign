"use strict";
var ChangeSet = (function () {
    function ChangeSet(diffs) {
        if (diffs === void 0) { diffs = []; }
        this.diffs = diffs;
        this._prepare();
    }
    /* @internal */
    ChangeSet.prototype._prepare = function () {
        this.diffs = this.diffs.sort(function (a, b) { return a.index - b.index; });
    };
    ChangeSet.prototype.concat = function (other) {
        this._prepare();
        other._prepare();
        this.diffs = this.diffs.concat(other.diffs);
        return this;
    };
    ChangeSet.prototype.applyChangeSets = function (str) {
        this._prepare();
        var delta = 0;
        this.diffs.forEach(function (data) {
            var result = data.expected.replace(/\$([0-9]{1,2})/g, function (match, g1) {
                var index = parseInt(g1, 10);
                if (index === 0 || (data.matches.length - 1) < index) {
                    return match;
                }
                return data.matches[index] || "";
            });
            str = str.slice(0, data.index + delta) + result + str.slice(data.index + delta + data.matches[0].length);
            delta += result.length - data.matches[0].length;
        });
        return str;
    };
    ChangeSet.prototype.subtract = function (subtrahend) {
        this._prepare();
        subtrahend._prepare();
        var result = new ChangeSet(this.diffs.map(function (v) { return v; }));
        var m = 0;
        var s = 0;
        while (true) {
            var minuendDiff = result.diffs[m];
            var subtrahendDiff = subtrahend.diffs[s];
            if (!minuendDiff || !subtrahendDiff) {
                break;
            }
            if (!minuendDiff.isEncloser(subtrahendDiff) && minuendDiff.isCollide(subtrahendDiff)) {
                result.diffs.splice(m, 1);
                continue;
            }
            if (minuendDiff.isBefore(subtrahendDiff)) {
                m++;
            }
            else {
                s++;
            }
        }
        return result;
    };
    ChangeSet.prototype.intersect = function (audit) {
        this._prepare();
        audit._prepare();
        var result = new ChangeSet();
        var a = 0;
        var b = 0;
        while (true) {
            var baseDiff = this.diffs[a];
            var auditDiff = audit.diffs[b];
            if (!baseDiff || !auditDiff) {
                break;
            }
            if (baseDiff.isCollide(auditDiff) && result.diffs.indexOf(baseDiff) === -1) {
                result.diffs.push(baseDiff);
            }
            if (baseDiff.isBefore(auditDiff)) {
                a++;
            }
            else {
                b++;
            }
        }
        return result;
    };
    return ChangeSet;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ChangeSet;
//# sourceMappingURL=changeset.js.map