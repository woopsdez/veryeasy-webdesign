{"version":3,"file":"rule.js","sourceRoot":"","sources":["rule.ts"],"names":[],"mappings":"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","sourcesContent":["import * as r from \"./utils/regexp\";\n\nimport Options from \"./options\";\nimport RuleSpec from \"./ruleSpec\";\n\nimport Diff from \"./changeset/diff\";\nimport ChangeSet from \"./changeset/changeset\";\n\nimport * as raw from \"./raw\";\n\nexport default class Rule {\n    expected: string;\n    pattern: RegExp;\n    regexpMustEmpty: string;\n    options: Options;\n    specs: RuleSpec[];\n    raw: any /* raw.Rule */;\n\n    constructor(src: string | raw.Rule) {\n        if (!src) {\n            throw new Error(\"src is requried\");\n        }\n        let rawRule: raw.Rule;\n        if (typeof src === \"string\") {\n            rawRule = {\n                expected: src,\n            };\n        } else {\n            rawRule = src;\n        }\n        this.options = new Options(this, rawRule.options);\n\n        this.expected = rawRule.expected;\n        if (this.expected == null) {\n            throw new Error(\"expected is required\");\n        }\n\n        this.pattern = this._patternToRegExp(rawRule.pattern || rawRule.patterns);\n        if (this.pattern == null) {\n            throw new Error(\"pattern is required\");\n        }\n\n        this.regexpMustEmpty = rawRule.regexpMustEmpty;\n\n        // for JSON order\n        let options = this.options;\n        delete this.options;\n        this.options = options;\n\n        this.specs = (rawRule.specs || []).map(spec => new RuleSpec(spec));\n\n        this.raw = rawRule;\n\n        this.check();\n    }\n\n    /* @internal */\n    _patternToRegExp(pattern: string | string[]): RegExp {\n        let result: RegExp;\n        if (pattern == null) {\n            result = r.spreadAlphaNum(this.expected);\n            if (this.options.wordBoundary) {\n                result = r.addBoundary(result);\n            }\n            return r.addDefaultFlags(result);\n        }\n        if (typeof pattern === \"string\") {\n            result = r.parseRegExpString(pattern);\n            if (result) {\n                return r.addDefaultFlags(result);\n            }\n            if (this.options.wordBoundary) {\n                result = r.addBoundary(pattern);\n            } else {\n                result = new RegExp(r.escapeSpecialChars(pattern));\n            }\n            return r.addDefaultFlags(result);\n        } else if (pattern instanceof Array) {\n            result = r.combine.apply(null, pattern.map(p => this._patternToRegExp(p)));\n            return r.addDefaultFlags(result);\n        }\n        return result;\n    }\n\n    reset() {\n        this.pattern.lastIndex = 0;\n    }\n\n    check() {\n        this.specs.forEach(spec => {\n            let result = this.applyRule(spec.from).applyChangeSets(spec.from);\n            if (spec.to !== result) {\n                throw new Error(`${this.expected} spec failed. \"${spec.from}\", expected \"${spec.to}\", but got \"${result}\", ${this.pattern}`);\n            }\n        });\n    }\n\n    applyRule(content: string): ChangeSet {\n        this.reset();\n        let resultList = r.collectAll(this.pattern, content);\n        let diffs = resultList\n            .map(result => {\n                // JavaScriptでの正規表現では /(?<!記|大)事/ のような書き方ができない\n                // /(記|大)事/ で regexpMustEmpty $1 の場合、第一グループが空じゃないとマッチしない、というルールにして回避\n                if (this.regexpMustEmpty) {\n                    let match = /^\\$([0-9]+)$/.exec(this.regexpMustEmpty);\n                    if (match == null) {\n                        throw new Error(`${this.expected} target failed. please use $1 format.`);\n                    }\n                    let index = parseInt(match[1], 10);\n                    if (result[index]) {\n                        return null;\n                    }\n                }\n                return new Diff(this.pattern, this.expected, result.index, <string[]>Array.prototype.slice.call(result), this);\n            })\n            .filter(v => !!v);\n        return new ChangeSet(diffs);\n    }\n\n    toJSON() {\n        let alt: any = {};\n        for (let key in this) {\n            if (key.indexOf(\"_\") === 0) {\n                continue;\n            }\n            let value = (<any>this)[key];\n            if (value instanceof RegExp) {\n                alt[key] = value.toString();\n                continue;\n            }\n            alt[key] = value;\n        }\n        return alt;\n    }\n}\n"]}