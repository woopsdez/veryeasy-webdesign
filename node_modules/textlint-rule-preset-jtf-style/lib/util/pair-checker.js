// LICENSE : MIT
"use strict";
/**
 * 「と」といったペアがちゃんと閉じられているかをチェックします
 * @param {object} context
 * @param {string} left
 * @param {string} right
 * @returns {object}
 */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkPair = checkPair;

var _assert = require("assert");

var _assert2 = _interopRequireDefault(_assert);

var _textlintRuleHelper = require("textlint-rule-helper");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function checkPair(context, _ref) {
    var _ref3;

    var left = _ref.left,
        right = _ref.right;

    (0, _assert2.default)(left);
    (0, _assert2.default)(right);
    var Syntax = context.Syntax,
        RuleError = context.RuleError,
        report = context.report,
        getSource = context.getSource;

    var helper = new _textlintRuleHelper.RuleHelper(context);
    var isInParagraph = false;
    var currentStrInParagraph = [];
    /**
     * `Str` nodeの配列を受け取り、pairが見つからないnodeを返す
     * @param {Object} currentStrInParagraph
     * @returns {{node, index}[]}
     */
    var foundMissingPairNodes = function foundMissingPairNodes(currentStrInParagraph) {
        var foundLeft = false;
        var matchParentheses = [];
        currentStrInParagraph.forEach(function (node) {
            var text = getSource(node);
            // left を探す
            var leftIndex = -1;
            if (!foundLeft) {
                leftIndex = text.indexOf(left);
                if (leftIndex !== -1) {
                    matchParentheses.push({
                        node: node,
                        index: leftIndex
                    });
                    foundLeft = true;
                }
            }
            // right を探す
            var pairIndex = text.indexOf(right, leftIndex + 1);
            if (pairIndex !== -1) {
                matchParentheses.pop();
                foundLeft = false;
            }
        });
        return matchParentheses;
    };
    return _ref3 = {}, _defineProperty(_ref3, Syntax.Paragraph, function (node) {
        if (helper.isChildNode(node, [Syntax.BlockQuote])) {
            return;
        }
        currentStrInParagraph = [];
        isInParagraph = true;
    }), _defineProperty(_ref3, Syntax.Str, function (node) {
        if (!isInParagraph) {
            return;
        }
        currentStrInParagraph.push(node);
    }), _defineProperty(_ref3, Syntax.Paragraph + ":exit", function undefined() {
        var missingPairList = foundMissingPairNodes(currentStrInParagraph);
        // 探索おわり
        isInParagraph = false;
        // 全ての対が見つかったなら配列は空になる
        if (missingPairList.length === 0) {
            return;
        }
        missingPairList.forEach(function (_ref2) {
            var node = _ref2.node,
                index = _ref2.index;

            report(node, new RuleError(left + "\u306E\u5BFE\u3068\u306A\u308B" + right + "\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002" + left + right, {
                index: index
            }));
        });
    }), _ref3;
}
//# sourceMappingURL=pair-checker.js.map