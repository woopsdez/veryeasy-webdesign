{"version":3,"sources":["../../src/util/pair-checker.js"],"names":["checkPair","context","left","right","Syntax","RuleError","report","getSource","helper","isInParagraph","currentStrInParagraph","foundMissingPairNodes","foundLeft","matchParentheses","forEach","text","node","leftIndex","indexOf","push","index","pairIndex","pop","Paragraph","isChildNode","BlockQuote","Str","missingPairList","length"],"mappings":"AAAA;AACA;AACA;;;;;;;;;;;QASgBA,S,GAAAA,S;;AAFhB;;;;AACA;;;;;;AACO,SAASA,SAAT,CAAmBC,OAAnB,QAA6C;AAAA;;AAAA,QAAfC,IAAe,QAAfA,IAAe;AAAA,QAATC,KAAS,QAATA,KAAS;;AAChD,0BAAOD,IAAP;AACA,0BAAOC,KAAP;AAFgD,QAG1CC,MAH0C,GAGDH,OAHC,CAG1CG,MAH0C;AAAA,QAGlCC,SAHkC,GAGDJ,OAHC,CAGlCI,SAHkC;AAAA,QAGvBC,MAHuB,GAGDL,OAHC,CAGvBK,MAHuB;AAAA,QAGfC,SAHe,GAGDN,OAHC,CAGfM,SAHe;;AAIhD,QAAIC,SAAS,mCAAeP,OAAf,CAAb;AACA,QAAIQ,gBAAgB,KAApB;AACA,QAAIC,wBAAwB,EAA5B;AACA;;;;;AAKA,QAAMC,wBAAwB,SAAxBA,qBAAwB,wBAAyB;AACnD,YAAIC,YAAY,KAAhB;AACA,YAAIC,mBAAmB,EAAvB;AACAH,8BAAsBI,OAAtB,CAA8B,gBAAQ;AAClC,gBAAMC,OAAOR,UAAUS,IAAV,CAAb;AACA;AACA,gBAAIC,YAAY,CAAC,CAAjB;AACA,gBAAI,CAACL,SAAL,EAAgB;AACZK,4BAAYF,KAAKG,OAAL,CAAahB,IAAb,CAAZ;AACA,oBAAIe,cAAc,CAAC,CAAnB,EAAsB;AAClBJ,qCAAiBM,IAAjB,CAAsB;AAClBH,kCADkB;AAElBI,+BAAOH;AAFW,qBAAtB;AAIAL,gCAAY,IAAZ;AACH;AACJ;AACD;AACA,gBAAIS,YAAYN,KAAKG,OAAL,CAAaf,KAAb,EAAoBc,YAAY,CAAhC,CAAhB;AACA,gBAAII,cAAc,CAAC,CAAnB,EAAsB;AAClBR,iCAAiBS,GAAjB;AACAV,4BAAY,KAAZ;AACH;AACJ,SApBD;AAqBA,eAAOC,gBAAP;AACH,KAzBD;AA0BA,8CACKT,OAAOmB,SADZ,YACuBP,IADvB,EAC6B;AACrB,YAAIR,OAAOgB,WAAP,CAAmBR,IAAnB,EAAyB,CAACZ,OAAOqB,UAAR,CAAzB,CAAJ,EAAmD;AAC/C;AACH;AACDf,gCAAwB,EAAxB;AACAD,wBAAgB,IAAhB;AACH,KAPL,0BAQKL,OAAOsB,GARZ,YAQiBV,IARjB,EAQuB;AACf,YAAI,CAACP,aAAL,EAAoB;AAChB;AACH;AACDC,8BAAsBS,IAAtB,CAA2BH,IAA3B;AACH,KAbL,0BAcQZ,OAAOmB,SAdf,iCAcmC;AAC3B,YAAMI,kBAAkBhB,sBAAsBD,qBAAtB,CAAxB;AACA;AACAD,wBAAgB,KAAhB;AACA;AACA,YAAIkB,gBAAgBC,MAAhB,KAA2B,CAA/B,EAAkC;AAC9B;AACH;AACDD,wBAAgBb,OAAhB,CAAwB,iBAAqB;AAAA,gBAAlBE,IAAkB,SAAlBA,IAAkB;AAAA,gBAAZI,KAAY,SAAZA,KAAY;;AACzCd,mBACIU,IADJ,EAEI,IAAIX,SAAJ,CAAiBH,IAAjB,sCAA6BC,KAA7B,8DAA8CD,IAA9C,GAAqDC,KAArD,EAA8D;AAC1DiB;AAD0D,aAA9D,CAFJ;AAMH,SAPD;AAQH,KA9BL;AAgCH","file":"pair-checker.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\n/**\n * 「と」といったペアがちゃんと閉じられているかをチェックします\n * @param {object} context\n * @param {string} left\n * @param {string} right\n * @returns {object}\n */\nimport assert from \"assert\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nexport function checkPair(context, { left, right }) {\n    assert(left);\n    assert(right);\n    let { Syntax, RuleError, report, getSource } = context;\n    let helper = new RuleHelper(context);\n    let isInParagraph = false;\n    let currentStrInParagraph = [];\n    /**\n     * `Str` nodeの配列を受け取り、pairが見つからないnodeを返す\n     * @param {Object} currentStrInParagraph\n     * @returns {{node, index}[]}\n     */\n    const foundMissingPairNodes = currentStrInParagraph => {\n        let foundLeft = false;\n        let matchParentheses = [];\n        currentStrInParagraph.forEach(node => {\n            const text = getSource(node);\n            // left を探す\n            let leftIndex = -1;\n            if (!foundLeft) {\n                leftIndex = text.indexOf(left);\n                if (leftIndex !== -1) {\n                    matchParentheses.push({\n                        node,\n                        index: leftIndex\n                    });\n                    foundLeft = true;\n                }\n            }\n            // right を探す\n            let pairIndex = text.indexOf(right, leftIndex + 1);\n            if (pairIndex !== -1) {\n                matchParentheses.pop();\n                foundLeft = false;\n            }\n        });\n        return matchParentheses;\n    };\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            currentStrInParagraph = [];\n            isInParagraph = true;\n        },\n        [Syntax.Str](node) {\n            if (!isInParagraph) {\n                return;\n            }\n            currentStrInParagraph.push(node);\n        },\n        [`${Syntax.Paragraph}:exit`]() {\n            const missingPairList = foundMissingPairNodes(currentStrInParagraph);\n            // 探索おわり\n            isInParagraph = false;\n            // 全ての対が見つかったなら配列は空になる\n            if (missingPairList.length === 0) {\n                return;\n            }\n            missingPairList.forEach(({ node, index }) => {\n                report(\n                    node,\n                    new RuleError(`${left}の対となる${right}が見つかりません。${left}${right}`, {\n                        index\n                    })\n                );\n            });\n        }\n    };\n}\n"]}